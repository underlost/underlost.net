---
layout: posts
title: Welcome to the new Underlost
slug: new-underlost
date: 2014-04-03
snippet: "Introducing the new, and improved underlost.net. I spent the last couple months constantly developing and improving it, and I'm finally happy with the results."
---

<p class="lead">Introducing the new, and improved underlost.net. I spent the last couple months constantly developing and improving it, and I'm finally happy with the results.</p>

### Development

While I wrote Replica, you would think I'd have just used that to power the site. However, I felt having a full blown content management system was a little out of place. It was simply overkill. I don't really update the site that often, and really all I need was a static site to host a few dozen HTML files. I dodnt need anything too fancy, nothing dynamic, and surely not a database to house all the content. Enter Jekyll. For those unfamilar, Jekyll is a static site generator written in Ruby. I've had experience with using it to an extent deploying sites on Github. It also uses a liquid template system, similar to what Django uses for it's own templates, so naturally I felt right at home.

Now, I understand my site is a bit peculiar in the way things are setup. Instead of using jekyll's built in generator for blog posts, I rely on my own YML file for maintaining the blog data. '_posts' is reserved for generating the content for the project pages. Why not the other way around? I had thought about this at first too, but after some trial and error, this method is just simpler. Not all posts will use the same layouts, and this way I can keep assets for certain posts a little more organized instead of dumping it all in ta single directory. I still maintain a data file for projects as well, for the mobile /projects/ page.


### Deployment

Not really being into the node.js hype when it first came out, I dismissed the vast uses of it. It wasnt until I learned to use it at work had I realized the capabilities of Node, not just as a backend, but as a tool for front end development as well. Enter the task manager, Grunt. With it Ive managed to automate some of the more tidious jobs like image optimization and CSS compilation. To be more specific, in order of execution:

* Compile LESS to CSS
* Run autoprefixer on CSS to add vendor prefixes to CSS rules where needed
* Compile all JS files into a single file
* Minify CSS/JS
* Run validation tests on HTML generated by Jekyll
* Deploy the compiled '_site' directory to Github

Finally being happy with the finished results of the redesign for my site, it was time to make it live. But, where? I initially relied on Heroku with a modified buildpack and Unicorn/memcache setup, but this was a little overkill. While Heroku is a great service, it can also get quite expensive once you start scaling past their first free 'dyno'. Github Pages would be the ideal free solution, but Github doesn't allow custom plugins, nor an alternate "source" directory inside '_config.yml'. So that was also out of the question.

In the end, I settled with a middle of the road solution, using Amazon's S3 amd Cloudfront services, with Heroku acting as a sort of staging area. I'm still using my initial setup of Unicorn/memcache, but I've scaled it down to one dyno to stay on their free plan. This way, I can test across multiple machines, browsers and devices a little more eaisly than I could on just my local machine. The difference is now Im also using the wonderful s3_website gem. Once deployed to Heroku, I use heroku's CLI to execute an s3_website push to S3. The beauty in this is rather than storing my credentials in a text file, or locally as env variables, they're saved with Heroku, allowing me to work on the site from any machine. 
